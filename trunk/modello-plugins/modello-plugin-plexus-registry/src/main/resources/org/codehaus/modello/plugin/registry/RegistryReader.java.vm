package ${package};

import org.codehaus.plexus.registry.Registry;

// Util imports
import java.util.*;

// Model class imports
#foreach ( $class in $classes )
#if ( ${class.packageName} != ${package} )
import ${class.packageName}.${class.name};
#end
#end

## TODO! make it possible to change property name via metadata
## TODO! handle other types

#macro ( handlePrimitive $localVar $registryVar $name $type $getter )
#if ( $type == "boolean" )
        $type $localVar = ${registryVar}.getBoolean( prefix + "${name}", $getter );
#elseif ( $type == "char" )
    $javaTool.fail( "Type not yet handled: $type" )
#elseif ( $type == "double" )
    $javaTool.fail( "Type not yet handled: $type" )
#elseif ( $type == "float" )
    $javaTool.fail( "Type not yet handled: $type" )
#elseif ( $type == "int" )
        $type $localVar = ${registryVar}.getInt( prefix + "${name}", $getter );
#elseif ( $type == "long" )
    $javaTool.fail( "Type not yet handled: $type" )
#elseif ( $type == "short" )
    $javaTool.fail( "Type not yet handled: $type" )
#elseif ( $type == "String" )
        $type $localVar = ${registryVar}.getString( prefix + "${name}", $getter );
#elseif ( $type == "Boolean" )
    $javaTool.fail( "Type not yet handled: $type" )
#elseif ( $type == "Date" )
    $javaTool.fail( "Type not yet handled: $type" )
#elseif ( $type == "DOM" )
    $javaTool.fail( "Type not yet handled: $type" )
#else
    $javaTool.fail( "Unknown type: $type" )
#end
#end

#macro ( fillCollection $uncapFieldName $to )
#set ( $singularFieldName = $javaTool.singular($uncapFieldName) )
#if ( $model.hasClass( $to, $version ) )
## TODO! hide the (0) etc implementation details
## TODO! make it possible to have unwrapped lists via metadata
        do
        {
            subRegistry = registry.getSubRegistry( prefix + "${uncapFieldName}.${singularFieldName}(" + ${uncapFieldName}.size() + ")" );
            if ( !subRegistry.isEmpty() )
            {
                $to v = read${to}( "", subRegistry );
                ${uncapFieldName}.add( v );
            }
        }
        while ( !subRegistry.isEmpty() );
#else
        ${uncapFieldName}.addAll( registry.getList( prefix + "${uncapFieldName}.${singularFieldName}" ) );
#end
#end

/**
 * Generate Plexus Registry input mechanism for model '${model.name}'.
 */
public class ${model.name}RegistryReader
{
    public ${model.name} read( Registry registry )
    {
#set ( $root = $model.getClass( $model.getRoot( $version ), $version ) )
        return read${root.name}( "", registry );
    }

#foreach ( $class in $classes )
    private ${class.name} read${class.name}( String prefix, Registry registry )
    {
        Registry subRegistry;

        ${class.name} value = new ${class.name}();

#foreach ( $field in $class.getAllFields( $version, true ) )
## TODO: handle aliases
## TODO: handle required (and optional for those that cry when the registry item is not found)
#set ( $uncapFieldName = $javaTool.uncapitalise($field.name) )
#if ( $field.primitive )
#handlePrimitive( $uncapFieldName "registry" $field.name $field.type "value.${javaTool.makeGetter( $field )}()" )
#else
#set ( $assoc = $field )
#if ( $assoc.multiplicity == "1" )
        $assoc.to $uncapFieldName = read${assoc.to}( prefix + "${uncapFieldName}.", registry );
#else
#if ( $assoc.type == "java.util.List" )
        List $uncapFieldName = $assoc.defaultValue;
#fillCollection( $uncapFieldName $assoc.to )
#elseif ( $assoc.type == "java.util.Set" )
        Set $uncapFieldName = $assoc.defaultValue;
#fillCollection( $uncapFieldName $assoc.to )
#elseif ( $assoc.type == "java.util.Map" || $assoc.type == "java.util.Properties" )
## TODO! make it possible to have exploded maps in xml via metadata
        subRegistry = registry.getSubRegistry( prefix + "${uncapFieldName}" );
        $assoc.type $uncapFieldName = subRegistry.asProperties();
#else
    $javaTool.fail( "Unknown collection type: $assoc.type" )
#end
#end
#end
        value.${javaTool.makeSetter( $field )}( $uncapFieldName );
#end

        return value;
    }
    
#end
}
